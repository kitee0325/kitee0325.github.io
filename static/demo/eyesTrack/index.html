<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graph Layout</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        height: 100vh;
        box-sizing: border-box;
      }

      .container {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 20px;
        height: calc(100vh - 40px);
        max-height: 900px;
      }

      .main-graph {
        border: 2px solid #f4a460;
        border-radius: 10px;
        padding: 20px;
        position: relative;
      }

      .main-graph h2 {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 1;
        margin: 0;
        padding: 5px 10px;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 5px;
      }

      .main-graph svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: 20px;
        box-sizing: border-box;
      }

      .right-panel {
        display: grid;
        grid-template-rows: 1fr 1fr auto;
        gap: 20px;
      }

      .control-panel {
        border: 2px solid #9370db;
        border-radius: 10px;
        padding: 20px;
      }

      .calibration-panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .detail {
        border: 2px solid #90ee90;
        border-radius: 10px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .webgazer-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        flex: 1;
        min-height: 240px;
      }

      .video-feed {
        width: 100%;
        height: 240px;
        border: 2px solid #ccc;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .feedback-container {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 2px solid #ccc;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.05);
        height: 240px;
      }

      #webgazerVideoContainer {
        position: fixed !important;
        top: -999px !important;
        left: -999px !important;
        transition: all 0.3s ease-in-out;
      }

      .video-feed #webgazerVideoContainer {
        position: relative !important;
        top: unset !important;
        left: unset !important;
        width: 100% !important;
        height: 100% !important;
      }

      #webgazerFaceFeedbackBox,
      #webgazerFaceOverlay {
        position: fixed !important;
        top: -999px !important;
        left: -999px !important;
        transition: all 0.3s ease-in-out;
      }

      .feedback-container #webgazerFaceFeedbackBox,
      .feedback-container #webgazerFaceOverlay {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
      }

      video {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
      }

      h2 {
        margin: 0;
        margin-bottom: 10px;
        font-family: Arial, sans-serif;
      }

      .links line {
        stroke: #999;
        stroke-width: 1px;
        stroke-opacity: 0.6;
      }

      .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
      }

      .node text {
        font-family: Arial, sans-serif;
        font-size: 10px;
        opacity: 0;
        pointer-events: none;
      }

      .node.fisheye text {
        opacity: 1;
      }

      .node:hover text {
        opacity: 1;
      }

      .node:hover circle {
        stroke: #000;
        stroke-width: 2px;
      }

      .bar-chart rect {
        transition: opacity 0.2s;
      }

      .bar-chart text {
        font-family: Arial, sans-serif;
        font-size: 12px;
      }

      .bar-chart .bar:hover rect {
        opacity: 0.7;
      }

      .bar-chart .bar rect.highlighted {
        stroke: #000;
        stroke-width: 2px;
      }

      .nodes circle.dimmed {
        opacity: 0.2;
      }

      .links line.dimmed {
        opacity: 0.1;
      }

      .fisheye-lens {
        pointer-events: none;
        fill: none;
        stroke: #666;
        stroke-width: 1px;
        stroke-dasharray: 5, 3;
        opacity: 0.6;
      }

      .calibration-button {
        width: 100%;
        background: #4caf50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s;
      }

      .calibration-button:hover {
        background: #45a049;
      }

      .calibration-button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }

      .calibration-point {
        position: fixed;
        width: 20px;
        height: 20px;
        background: red;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        display: none;
        z-index: 9999;
        box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.2);
          opacity: 0.8;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      .calibration-point.active {
        display: block;
      }

      .calibration-status {
        margin-top: 10px;
        font-size: 14px;
        color: #666;
      }

      .node {
        position: relative;
      }

      .toggle-button {
        width: 100%;
        background: #4682b4;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s;
        margin-top: 10px;
      }

      .toggle-button:hover {
        background: #36648b;
      }

      .toggle-button.active {
        background: #36648b;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="main-graph">
        <h2 style="color: #f4a460">Character Relationships</h2>
        <svg></svg>
      </div>
      <div class="right-panel">
        <div class="sub-graph">
          <h2 style="color: #4682b4">Top 5 First Letters</h2>
          <svg width="100%" height="90%"></svg>
        </div>
        <div class="detail">
          <h2 style="color: #4a8c4a">Eye Tracking Feedback</h2>
          <div class="webgazer-container">
            <div id="webgazerVideoFeed" class="video-feed"></div>
            <div class="feedback-container" id="feedback"></div>
          </div>
        </div>
        <div class="control-panel">
          <div class="calibration-panel">
            <button id="calibrateBtn" class="calibration-button">
              Start Calibration
            </button>
            <div id="calibrationStatus" class="calibration-status">
              Status: Initializing eye tracking...
            </div>
            <button id="toggleTrackingBtn" class="toggle-button">
              Switch to Mouse Tracking
            </button>
          </div>
        </div>
      </div>
    </div>
    <div id="calibrationPoint" class="calibration-point"></div>

    <script>
      // 校准相关变量
      let isCalibrating = false;
      let currentPoint = 0;
      let samplesPerPoint = 0;
      const requiredSamplesPerPoint = 20; // 每个点收集20个样本
      const calibrationDelay = 1000; // 注视点出现后等待1秒再开始收集样本
      const maxTimePerPoint = 2000; // 每个点最多采样2秒
      let samplingStartTime = 0;

      // 增加校准点数量和优化分布
      const calibrationPoints = [
        // 外圈8个点
        { x: 10, y: 10 }, // 左上
        { x: 50, y: 10 }, // 上中
        { x: 90, y: 10 }, // 右上
        { x: 10, y: 50 }, // 左中
        { x: 90, y: 50 }, // 右中
        { x: 10, y: 90 }, // 左下
        { x: 50, y: 90 }, // 下中
        { x: 90, y: 90 }, // 右下
        // 中心点
        { x: 50, y: 50 }, // 中心
      ];

      const calibrateBtn = document.getElementById('calibrateBtn');
      const calibrationPoint = document.getElementById('calibrationPoint');
      const calibrationStatus = document.getElementById('calibrationStatus');

      // 初始状态下禁用校准按钮
      calibrateBtn.disabled = true;
      calibrationStatus.textContent = 'Status: Initializing eye tracking...';

      // 添加点击事件监听器
      calibrateBtn.addEventListener('click', startCalibration);

      function showNextCalibrationPoint() {
        if (currentPoint >= calibrationPoints.length) {
          endCalibration();
          return;
        }

        console.log('Showing calibration point', currentPoint + 1);
        const point = calibrationPoints[currentPoint];

        // 计算点的实际位置（相对于视口）
        const viewportX = (point.x / 100) * window.innerWidth;
        const viewportY = (point.y / 100) * window.innerHeight;

        console.log('Point position:', viewportX, viewportY);

        // 显示校准点
        const calibrationPoint = document.getElementById('calibrationPoint');
        calibrationPoint.style.left = viewportX + 'px';
        calibrationPoint.style.top = viewportY + 'px';
        calibrationPoint.classList.add('active');
        calibrationPoint.style.display = 'block';
        calibrationPoint.style.zIndex = '9999';

        // 重置采样计数
        samplesPerPoint = 0;

        // 等待用户注视点一段时间后再开始收集样本
        setTimeout(() => {
          console.log(
            'Starting to collect samples for point',
            currentPoint + 1
          );
          samplingStartTime = Date.now();
          collectSamples(viewportX, viewportY);
        }, calibrationDelay);
      }

      function startCalibration() {
        if (!webgazerInitialized) {
          console.log('Cannot start calibration - WebGazer not initialized');
          return;
        }
        console.log('Starting calibration process');
        isCalibrating = true;
        currentPoint = 0;
        samplesPerPoint = 0;
        calibrateBtn.disabled = true; // 在校准过程中禁用按钮
        webgazer.clearData(); // 清除之前的校准数据
        calibrationStatus.textContent =
          'Status: Calibrating... Look at the red dot';

        // 确保校准点可见
        const calibrationPoint = document.getElementById('calibrationPoint');
        calibrationPoint.style.cssText = ''; // 清除之前的所有样式
        calibrationPoint.classList.remove('active'); // 移除之前的active类

        // 立即显示第一个校准点
        showNextCalibrationPoint();
      }

      function collectSamples(x, y) {
        if (!isCalibrating) return;

        const currentTime = Date.now();
        console.log(
          `Collecting sample ${
            samplesPerPoint + 1
          }/${requiredSamplesPerPoint}, time elapsed: ${
            currentTime - samplingStartTime
          }ms`
        );

        // 检查是否超过最大采样时间
        if (currentTime - samplingStartTime >= maxTimePerPoint) {
          console.log('Max sampling time reached for point', currentPoint + 1);
          samplesPerPoint = 0; // 重置采样计数
          currentPoint++;
          showNextCalibrationPoint();
          return;
        }

        // 检查是否已收集足够的样本
        if (samplesPerPoint >= requiredSamplesPerPoint) {
          console.log('Collected enough samples for point', currentPoint + 1);
          samplesPerPoint = 0; // 重置采样计数
          currentPoint++;
          showNextCalibrationPoint();
          return;
        }

        // 获取当前的眼睛图像数据
        webgazer
          .getCurrentPrediction()
          .then((prediction) => {
            if (prediction && prediction.eyeFeatures) {
              // 使用眼睛特征数据进行校准
              webgazer.addGazeData(
                x,
                y,
                prediction.eyeFeatures.left,
                prediction.eyeFeatures.right
              );
              samplesPerPoint++;

              // 更新状态显示
              calibrationStatus.textContent = `Status: Calibrating... Point ${
                currentPoint + 1
              }/${
                calibrationPoints.length
              } (${samplesPerPoint}/${requiredSamplesPerPoint})`;

              // 继续收集样本
              if (isCalibrating) {
                setTimeout(() => collectSamples(x, y), 100);
              }
            } else {
              console.log('No valid eye features detected, retrying...');
              // 如果没有检测到眼睛特征，短暂等待后重试
              if (isCalibrating) {
                setTimeout(() => collectSamples(x, y), 100);
              }
            }
          })
          .catch((error) => {
            console.error('Error getting eye features:', error);
            if (isCalibrating) {
              setTimeout(() => collectSamples(x, y), 100);
            }
          });
      }

      // WebGazer initialization
      let webgazerInitialized = false;

      async function initWebGazer() {
        if (webgazerInitialized) {
          console.log('WebGazer already initialized');
          return;
        }

        try {
          console.log('Starting WebGazer initialization...');
          calibrationStatus.textContent =
            'Status: Requesting camera permission...';

          // 配置 WebGazer
          webgazer.setRegression('ridge').setTracker('TFFacemesh');

          // 关闭WebGazer默认的视线点显示
          webgazer.params.showGazeDot = false;

          // 创建自定义的视线点
          const gazeDot = document.createElement('div');
          gazeDot.style.position = 'fixed';
          gazeDot.style.width = '10px';
          gazeDot.style.height = '10px';
          gazeDot.style.backgroundColor = 'red';
          gazeDot.style.borderRadius = '50%';
          gazeDot.style.pointerEvents = 'none';
          gazeDot.style.zIndex = '9999';
          gazeDot.style.transform = 'translate(-50%, -50%)';
          gazeDot.style.display = 'none';
          document.body.appendChild(gazeDot);

          // 设置视线追踪监听器
          webgazer.setGazeListener((data, timestamp) => {
            if (data == null || isCalibrating || !isEyeTracking) {
              gazeDot.style.display = 'none';
              if (!isEyeTracking) return;
              resetFisheyeEffect();
              return;
            }

            // 显示视线点
            gazeDot.style.display = 'block';
            gazeDot.style.left = data.x + 'px';
            gazeDot.style.top = data.y + 'px';

            // 获取图表容器的位置和尺寸
            const mainGraphRect = document
              .querySelector('.main-graph')
              .getBoundingClientRect();

            // 将视口坐标转换为相对于图表容器的坐标
            const svgX = data.x - mainGraphRect.left;
            const svgY = data.y - mainGraphRect.top;

            // 只在视线落在图表区域内时更新鱼眼效果
            if (
              svgX >= 0 &&
              svgX <= mainGraphRect.width &&
              svgY >= 0 &&
              svgY <= mainGraphRect.height
            ) {
              requestAnimationFrame(() => {
                updateFisheyeEffect(svgX, svgY);
              });
            } else {
              resetFisheyeEffect();
            }
          });

          // 开始 WebGazer
          await webgazer.begin();
          console.log('WebGazer.begin() completed');

          // 等待模型加载
          await new Promise((resolve) => setTimeout(resolve, 2000));

          // 配置显示选项
          webgazer.showVideo(true);
          webgazer.showFaceOverlay(true);
          webgazer.showFaceFeedbackBox(true);
          webgazer.showPredictionPoints(false); // 关闭默认预测点显示

          // 移动视频元素到正确的容器
          const videoFeed = document.getElementById('webgazerVideoFeed');
          const feedback = document.getElementById('feedback');

          // 移动视频容器
          const videoContainer = document.getElementById(
            'webgazerVideoContainer'
          );
          if (videoContainer && videoFeed) {
            videoFeed.appendChild(videoContainer);
          }

          // 移动人脸反馈框
          const faceFeedbackBox = document.getElementById(
            'webgazerFaceFeedbackBox'
          );
          const faceOverlay = document.getElementById('webgazerFaceOverlay');

          if (faceFeedbackBox && feedback) {
            feedback.appendChild(faceFeedbackBox);
          }
          if (faceOverlay && feedback) {
            feedback.appendChild(faceOverlay);
          }

          // 设置初始化标志
          webgazerInitialized = true;
          calibrationStatus.textContent = 'Status: Ready for calibration';
          calibrateBtn.disabled = false;

          console.log('WebGazer initialization completed');
        } catch (err) {
          console.error('WebGazer initialization error:', err);
          calibrationStatus.textContent =
            'Status: Failed to initialize eye tracking. Please ensure good lighting and face visibility, then refresh the page.';
          calibrateBtn.disabled = true;
          webgazerInitialized = false;
        }
      }

      // 更新鱼眼效果的函数
      const updateFisheyeEffect = (x, y) => {
        if (!fisheye || !fisheyeLens) {
          console.log('Fisheye or fisheyeLens not initialized');
          return;
        }

        // 更新鱼眼镜头位置
        fisheye.center = [x, y];
        fisheyeLens.style('display', 'block').attr('cx', x).attr('cy', y);

        // 更新节点位置
        d3.selectAll('.node').each(function (d) {
          const transformed = fisheye.transform(d.x, d.y);
          const distance = Math.sqrt(
            Math.pow(transformed.x - x, 2) + Math.pow(transformed.y - y, 2)
          );

          // 在鱼眼范围内的节点添加fisheye类并更新位置
          d3.select(this)
            .classed('fisheye', distance <= fisheye.radius)
            .attr(
              'transform',
              `translate(${transformed.x},${transformed.y}) scale(${transformed.z})`
            );
        });

        // 更新连线位置
        d3.selectAll('.links line').each(function (d) {
          const sourceTransformed = fisheye.transform(d.source.x, d.source.y);
          const targetTransformed = fisheye.transform(d.target.x, d.target.y);
          d3.select(this)
            .attr('x1', sourceTransformed.x)
            .attr('y1', sourceTransformed.y)
            .attr('x2', targetTransformed.x)
            .attr('y2', targetTransformed.y);
        });
      };

      // 重置鱼眼效果的函数
      const resetFisheyeEffect = () => {
        if (!fisheyeLens) return;

        fisheyeLens.style('display', 'none');

        d3.selectAll('.node')
          .classed('fisheye', false)
          .attr('transform', (d) => `translate(${d.x},${d.y})`);

        d3.selectAll('.links line')
          .attr('x1', (d) => d.source.x)
          .attr('y1', (d) => d.source.y)
          .attr('x2', (d) => d.target.x)
          .attr('y2', (d) => d.target.y);
      };

      // 声明全局变量
      let link, node;
      let simulation;
      let colorScale;
      let fisheye;
      let fisheyeLens;
      let isEyeTracking = true; // 默认使用眼球追踪

      // 获取SVG容器的尺寸
      const mainSvg = d3.select('.main-graph svg');
      const width = mainSvg.node().getBoundingClientRect().width;
      const height = mainSvg.node().getBoundingClientRect().height;

      // 调整鱼眼效果参数
      fisheye = {
        radius: 100,
        distortion: 2,
        center: [width / 2, height / 2],

        transform: function (x, y) {
          const dx = x - this.center[0];
          const dy = y - this.center[1];
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance >= this.radius) {
            return { x, y, z: 1 };
          }

          const k = 1 - Math.pow(distance / this.radius, 2);
          const distortionFactor = 1 + (this.distortion - 1) * k;

          return {
            x: this.center[0] + dx * distortionFactor,
            y: this.center[1] + dy * distortionFactor,
            z: distortionFactor,
          };
        },
      };

      // 创建鱼眼镜边框
      fisheyeLens = mainSvg
        .append('circle')
        .attr('class', 'fisheye-lens')
        .attr('r', fisheye.radius)
        .attr('cx', fisheye.center[0])
        .attr('cy', fisheye.center[1])
        .style('display', 'none');

      // 添加鼠标移动事件监听器
      mainSvg.on('mousemove', function (event) {
        if (!isEyeTracking) {
          const [x, y] = d3.pointer(event);
          requestAnimationFrame(() => {
            updateFisheyeEffect(x, y);
          });
        }
      });

      mainSvg.on('mouseleave', function () {
        if (!isEyeTracking) {
          resetFisheyeEffect();
        }
      });

      // 添加切换按钮事件监听器
      const toggleTrackingBtn = document.getElementById('toggleTrackingBtn');
      toggleTrackingBtn.addEventListener('click', function () {
        isEyeTracking = !isEyeTracking;
        this.textContent = isEyeTracking
          ? 'Switch to Mouse Tracking'
          : 'Switch to Eye Tracking';
        this.classList.toggle('active');
        resetFisheyeEffect();
      });

      // 创建自定义颜色方案
      const customColors = [
        '#1f77b4',
        '#ff7f0e',
        '#2ca02c',
        '#d62728',
        '#9467bd',
        '#8c564b',
        '#e377c2',
        '#7f7f7f',
        '#bcbd22',
        '#17becf',
        '#aec7e8',
        '#ffbb78',
        '#98df8a',
        '#ff9896',
        '#c5b0d5',
        '#c49c94',
        '#f7b6d2',
        '#c7c7c7',
        '#dbdb8d',
        '#9edae5',
      ];

      // 创建颜色比例尺
      colorScale = d3.scaleOrdinal().range(customColors);

      // 创建力导向图模拟器
      simulation = d3
        .forceSimulation()
        .force(
          'link',
          d3
            .forceLink()
            .id((d) => d.id)
            .distance(100)
        )
        .force('charge', d3.forceManyBody().strength(-100))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30))
        .stop(); // 初始时停止模拟，等数据加载后再启动

      // 定义节点颜色函数
      const getNodeColor = (node) => colorScale(node.id.charAt(0));

      // 拖拽相关函数
      const dragstarted = (event) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      };

      const dragged = (event) => {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      };

      const dragended = (event) => {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      };

      // 定义tick函数更新位置
      const ticked = () => {
        if (!link || !node) return;

        link
          .attr('x1', (d) => d.source.x)
          .attr('y1', (d) => d.source.y)
          .attr('x2', (d) => d.target.x)
          .attr('y2', (d) => d.target.y);

        node.attr('transform', (d) => {
          d.x = Math.max(20, Math.min(width - 20, d.x));
          d.y = Math.max(20, Math.min(height - 20, d.y));
          return `translate(${d.x},${d.y})`;
        });
      };

      // 获取SVG容器的尺寸
      const subSvg = d3.select('.sub-graph svg');
      const subWidth = subSvg.node().getBoundingClientRect().width;
      const subHeight = subSvg.node().getBoundingClientRect().height;

      // 加载数据
      d3.json('../../data/relation.json').then(function (graph) {
        // 计算节点的度（连接数）
        const nodeDegrees = new Map();
        graph.edges.forEach((edge) => {
          nodeDegrees.set(edge.source, (nodeDegrees.get(edge.source) || 0) + 1);
          nodeDegrees.set(edge.target, (nodeDegrees.get(edge.target) || 0) + 1);
        });

        // 获取所有首字母并统计数量
        const letterCounts = new Map();
        graph.nodes.forEach((node) => {
          const firstLetter = node.id.charAt(0);
          letterCounts.set(
            firstLetter,
            (letterCounts.get(firstLetter) || 0) + 1
          );
        });

        // 设置颜色比例尺的域
        colorScale.domain([...letterCounts.keys()].sort());

        // 获取前5个最多的首字母
        const top5Letters = Array.from(letterCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        // 创建连线
        link = mainSvg
          .append('g')
          .attr('class', 'links')
          .selectAll('line')
          .data(graph.edges)
          .enter()
          .append('line')
          .attr('stroke-width', (d) => Math.sqrt(d.data.value));

        // 创建节点组
        node = mainSvg
          .append('g')
          .attr('class', 'nodes')
          .selectAll('.node')
          .data(graph.nodes)
          .enter()
          .append('g')
          .attr('class', 'node')
          .call(
            d3
              .drag()
              .on('start', dragstarted)
              .on('drag', dragged)
              .on('end', dragended)
          );

        // 添加节点圆圈
        node
          .append('circle')
          .attr('r', (d) =>
            Math.max(8, Math.min(15, (nodeDegrees.get(d.id) || 0) * 0.8))
          )
          .attr('fill', (d) => getNodeColor(d));

        // 添加节点标签
        node
          .append('text')
          .text((d) => d.id)
          .attr('x', (d) =>
            Math.max(10, Math.min(15, (nodeDegrees.get(d.id) || 0) * 0.8))
          )
          .attr('y', 3);

        // 启动力导向图模拟
        simulation.nodes(graph.nodes);
        simulation.force('link').links(graph.edges);
        simulation.alpha(1).restart();
        simulation.on('tick', ticked);

        // 创建条形图
        const margin = { top: 20, right: 20, bottom: 30, left: 40 };
        const barWidth = subWidth - margin.left - margin.right;
        const barHeight = subHeight - margin.top - margin.bottom;

        // 创建比例尺
        const x = d3.scaleBand().range([0, barWidth]).padding(0.1);

        const y = d3.scaleLinear().range([barHeight, 0]);

        const barChart = subSvg
          .append('g')
          .attr('class', 'bar-chart')
          .attr('transform', `translate(${margin.left},${margin.top})`);

        x.domain(top5Letters.map((d) => d[0]));
        y.domain([0, d3.max(top5Letters, (d) => d[1])]);

        // 添加x轴
        barChart
          .append('g')
          .attr('transform', `translate(0,${barHeight})`)
          .call(d3.axisBottom(x));

        // 添加y轴
        barChart.append('g').call(d3.axisLeft(y));

        // 添加条形
        const bars = barChart
          .selectAll('.bar')
          .data(top5Letters)
          .enter()
          .append('g')
          .attr('class', 'bar')
          .on('mouseover', function (event, d) {
            // 高亮当前柱子
            d3.select(this).select('rect').classed('highlighted', true);

            // 突出显示相关节点，淡化其他节点
            node
              .select('circle')
              .classed('dimmed', (n) => n.id.charAt(0) !== d[0]);

            // 淡化不相关的连线
            link.classed(
              'dimmed',
              (l) =>
                l.source.id.charAt(0) !== d[0] && l.target.id.charAt(0) !== d[0]
            );
          })
          .on('mouseout', function () {
            // 移除高亮效果
            d3.select(this).select('rect').classed('highlighted', false);

            // 恢复所有节点和连线的显示
            node.select('circle').classed('dimmed', false);
            link.classed('dimmed', false);
          });

        bars
          .append('rect')
          .attr('x', (d) => x(d[0]))
          .attr('y', (d) => y(d[1]))
          .attr('width', x.bandwidth())
          .attr('height', (d) => barHeight - y(d[1]))
          .attr('fill', (d) => colorScale(d[0]));

        // 添加数值标签
        bars
          .append('text')
          .attr('x', (d) => x(d[0]) + x.bandwidth() / 2)
          .attr('y', (d) => y(d[1]) - 5)
          .attr('text-anchor', 'middle')
          .text((d) => d[1]);
      });

      window.onload = function () {
        // 创建并配置 canvas 元素
        const canvas = document.createElement('canvas');
        canvas.willReadFrequently = true;
        document.body.appendChild(canvas);

        initWebGazer()
          .then(() => {
            console.log('WebGazer initialized, ready for calibration');
          })
          .catch((error) => {
            console.error('Failed to initialize WebGazer:', error);
          });
      };

      // Clean up WebGazer and camera when leaving the page
      window.onbeforeunload = function () {
        if (webgazerInitialized) {
          // 添加初始化检查
          webgazer.end();
          webgazerInitialized = false;
          // 确保所有媒体流都被停止
          navigator.mediaDevices
            .getUserMedia({ video: true })
            .then((stream) => {
              stream.getTracks().forEach((track) => track.stop());
            })
            .catch(() => {});
        }
      };
    </script>
  </body>
</html>
